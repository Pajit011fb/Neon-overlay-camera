<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Camera with Neon Text Controls</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
        }

        .container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        video, canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #neonText {
            position: absolute;
            top: 50px;
            left: 50px;
            font-size: 48px;
            color: #0ff;
            z-index: 2;
            cursor: grab;
            background: rgba(255, 255, 255, 0.2); /* For masking effect */
            border-radius: 12px; /* Rounded edges */
            padding: 10px;
            transition: all 0.2s ease; /* Smooth transition for effects */
        }

        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 3;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 10px;
        }

        .controls label, .controls input, .controls button {
            color: white;
            display: block;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div class="container" id="background">
        <video id="cameraStream" autoplay playsinline></video>
        <canvas id="freezeCanvas" style="display:none;"></canvas>
        <div id="neonText" class="neon" draggable="true">Drag Me!</div>
        <div class="controls">
            <label for="neonInput">Text:</label>
            <input type="text" id="neonInput" value="Drag Me!">
            
            <label for="neonColor">Neon Color:</label>
            <input type="color" id="neonColor" value="#00ffff">
            
            <label for="spreadSlider">Neon Spread:</label>
            <input type="range" id="spreadSlider" min="0" max="50" value="10">
            
            <label for="darknessSlider">Neon Darkness:</label>
            <input type="range" id="darknessSlider" min="0" max="100" value="20">

            <label for="bgDarknessSlider">Background Darkness:</label>
            <input type="range" id="bgDarknessSlider" min="0" max="100" value="30">

            <label for="intensitySlider">Glow Intensity:</label>
            <input type="range" id="intensitySlider" min="0.1" max="3" step="0.1" value="1">

            <label for="sizeSlider">Text Size:</label>
            <input type="range" id="sizeSlider" min="10" max="200" value="48">

            <button id="freezeBtn">Freeze Camera</button>
        </div>
    </div>

    <script>
        // Access the back camera
        const video = document.getElementById('cameraStream');
        const canvas = document.getElementById('freezeCanvas');
        const ctx = canvas.getContext('2d');
        const neonText = document.getElementById('neonText');
        const neonInput = document.getElementById('neonInput');
        const neonColor = document.getElementById('neonColor');
        const spreadSlider = document.getElementById('spreadSlider');
        const darknessSlider = document.getElementById('darknessSlider');
        const bgDarknessSlider = document.getElementById('bgDarknessSlider');
        const intensitySlider = document.getElementById('intensitySlider');
        const sizeSlider = document.getElementById('sizeSlider');
        const freezeBtn = document.getElementById('freezeBtn');
        const background = document.getElementById('background');
        let cameraFrozen = false;

        // Request back camera
        navigator.mediaDevices.getUserMedia({ video: { facingMode: { exact: "environment" } } })
            .then((stream) => {
                video.srcObject = stream;
            })
            .catch((error) => {
                console.error("Error accessing camera: ", error);
            });

        // Function to freeze/unfreeze the camera
        freezeBtn.addEventListener('click', () => {
            if (!cameraFrozen) {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                video.style.display = 'none';
                canvas.style.display = 'block';
                freezeBtn.textContent = 'Unfreeze Camera';
            } else {
                video.style.display = 'block';
                canvas.style.display = 'none';
                freezeBtn.textContent = 'Freeze Camera';
            }
            cameraFrozen = !cameraFrozen;
        });

        // Function to update neon effect based on sliders and input
        function updateNeonEffect() {
            const spread = spreadSlider.value;
            const darkness = darknessSlider.value;
            const bgDarkness = bgDarknessSlider.value;
            const intensity = intensitySlider.value;
            const textSize = sizeSlider.value;
            const color = neonColor.value;
            const neonX = neonText.getBoundingClientRect().left + (neonText.offsetWidth / 2);
            const neonY = neonText.getBoundingClientRect().top + (neonText.offsetHeight / 2);

            const shadows = [];
            for (let i = 1; i <= 10; i++) {
                const blur = i * (spread / 10);
                const opacity = 1 - (i / 10);
                shadows.push(`0 0 ${blur}px rgba(${hexToRgb(color)}, ${opacity})`);
            }

            neonText.style.color = color;
            neonText.style.fontSize = `${textSize}px`;
            neonText.style.textShadow = shadows.join(', ');
            neonText.style.filter = `brightness(${intensity})`;

            // Radial gradient for neon darkness
            background.style.backgroundImage = `radial-gradient(circle at ${neonX}px ${neonY}px, rgba(0, 0, 0, ${darkness / 100}) 10%, rgba(0, 0, 0, 0) ${darkness * 2}%)`;

            // Background darkness for overall dark effect
            background.style.backgroundColor = `rgba(0, 0, 0, ${bgDarkness / 100})`;
        }

        function hexToRgb(hex) {
            let r = 0, g = 0, b = 0;
            if (hex.length === 7) {
                r = parseInt(hex.slice(1, 3), 16);
                g = parseInt(hex.slice(3, 5), 16);
                b = parseInt(hex.slice(5, 7), 16);
            }
            return `${r}, ${g}, ${b}`;
        }

        // Update text content when the user types
        neonInput.addEventListener('input', (e) => {
            neonText.textContent = e.target.value;
        });

        neonColor.addEventListener('input', updateNeonEffect);
        spreadSlider.addEventListener('input', updateNeonEffect);
        darknessSlider.addEventListener('input', updateNeonEffect);
        bgDarknessSlider.addEventListener('input', updateNeonEffect);
        intensitySlider.addEventListener('input', updateNeonEffect);
        sizeSlider.addEventListener('input', updateNeonEffect);
        updateNeonEffect();

        // For dragging functionality
        let offsetX, offsetY;
        neonText.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', null);
            offsetX = e.clientX - neonText.getBoundingClientRect().left;
            offsetY = e.clientY - neonText.getBoundingClientRect().top;
        });

        neonText.addEventListener('drag', (e) => {
            if (e.clientX !== 0 && e.clientY !== 0) {
                neonText.style.left = `${e.clientX - offsetX}px`;
                neonText.style.top = `${e.clientY - offsetY}px`;
                updateNeonEffect();
            }
        });

        neonText.addEventListener('dragend', (e) => {
            neonText.style.left = `${e.clientX - offsetX}px`;
            neonText.style.top = `${e.clientY - offsetY}px`;
            updateNeonEffect();
        });

        // For touch-based dragging and pinch-to-zoom
        let lastTouchDist = 0;

        neonText.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                                lastTouchDist = getTouchDistance(e.touches[0], e.touches[1]);
            } else {
                const touch = e.touches[0];
                offsetX = touch.clientX - neonText.getBoundingClientRect().left;
                offsetY = touch.clientY - neonText.getBoundingClientRect().top;
            }
        });

        neonText.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2) {
                const currentDist = getTouchDistance(e.touches[0], e.touches[1]);
                const scale = currentDist / lastTouchDist;
                neonText.style.transform = `scale(${scale})`;
            } else if (e.touches.length === 1) {
                const touch = e.touches[0];
                neonText.style.left = `${touch.clientX - offsetX}px`;
                neonText.style.top = `${touch.clientY - offsetY}px`;
                updateNeonEffect();
            }
        });

        neonText.addEventListener('touchend', (e) => {
            if (e.touches.length === 0) {
                neonText.style.transform = '';
            }
        });

        function getTouchDistance(touch1, touch2) {
            const dx = touch2.clientX - touch1.clientX;
            const dy = touch2.clientY - touch1.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }
    </script>
</body>
</html>

